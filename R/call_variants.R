call_variants <-
function(i, data, flanking_seqs, error_models){

  # Define empty vectors
  p <- c()
  ind1 <- c()
  ind2 <- c()
  ind3 <- c()
  
  # Get corresponding model for flanking seq i
  index <- which(error_models[,1] == flanking_seqs[i])
  
  # Get corresponding varscan calls for flanking seq i 
  index1 <- which(data$FlankingSeqGroup==flanking_seqs[i])
  
  # Get unique alt allele counts for flanking seq i
  alt_counts <- unique(altDepth(data)[index1])
  
  ### If error model exists for this flanking seq
  if(error_models$model[index] != "None"){
  
    # If error model for this flanking seq is exp (<10,000 mean depth)
    if (error_models$model[index] == "exp") {
      # Get estimate for exp decay rate
      estimate1 <- error_models$estimate1[index]
      
      # For each unique alt allele count
      for(j in alt_counts){
        # Compare alt allele count against error distribution
          # concatenate into vector with previous
        p <- c(p,1-pexp(j,estimate1))
      }
    
    # If error model for this flanking seq is weibull (>10,000 mean depth)
    } else if (error_models$model[index] == "weibull") {  
      # Get estimates for weibull parameters scale and shape
      estimate1 <- error_models$estimate1[index]
      estimate2 <- error_models$estimate2[index]
      
      # For each unique alt allele count
      for(j in alt_counts){
        # get pvalue from error dist for this alt allele count
        p <- c(p,1-pweibull(j,estimate1,estimate2))
      }  
    }
    
    # iterate through alt allele counts
    for(z in 1:length(alt_counts)){
      # find the rows in the varscan call corresponding to this alt allele count
      index2 <- which(altDepth(data)[index1] == alt_counts[z])
      # index for rows in varscan call corresponding to this alt count + Flanking Seq Group
      ind1 <- append(ind1,index1[index2])
      # p_value corresponding to each entry in ind1 
      ind2 <- append(ind2,rep(p[z],length(index1[index2])))
      # model used corresponding to each entry in ind1
      ind3 <- append(ind3,rep(error_models$model[index],length(index1[index2])))
    }
  
  ### If no error model exists for this flanking seq
    # same as above, but the pvalue is just 1????
  } else{
    for(z in 1:length(alt_counts)){
      index2 <- which(altDepth(data)[index1]==alt_counts[z])  
      ind1 <- append(ind1,index1[index2])
      ind2 <- append(ind2,rep(1,length(index1[index2])))
      ind3 <- append(ind3,rep("None",length(index1[index2])))
    }
  }
  return(list(ind1,ind2,ind3))
  
  ### WHERE IS MULTIPLE TESTING CORRECTION?
    # These p values are generated by looking at probability vs the distribution
}
